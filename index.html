<!DOCTYPE html>

<head>
  <meta charset="UTF-8">
  <title>Posenet Real Time Model</title>


    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/97/three.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow/1.2.2/tf.js"></script>
    <script src="https://unpkg.com/@tensorflow-models/posenet"></script>
    
    
    <link rel="stylesheet" href="https://use.typekit.net/tet7hit.css">

<style>
/* Style of axis */
body {
  background-color: #FFFFFF;
}

.flex {
    display: flex;
    justify-content: center;
    align-items: center;
}

h3 {
  color: #EFF6EE;
  font-family: interstate, sans-serif;
  font-weight: 250;
  font-style: normal;
}
canvas {
    position: absolute;
    top: 0;
    left: 0;
}
</style>
</head>

<body>

<div class='flex'>
  <h3>
    Posenet & three.js
  </h3>
</div>

<div class='flex'>
  <div id='main' style='display:none'>
      <video id="video" autoPlay = "true" playsinline style=" -moz-transform: scaleX(-1);
      -o-transform: scaleX(-1);
      -webkit-transform: scaleX(-1);
      transform: scaleX(-1);
      display: none;
      ">
      </video>
      <canvas id="output" />
  </div>  
</div>

<div id='threeContainer' class='flex'>
</div>
		<script id="vs-fireball" type="x-shader/x-vertex">
		#version 300 es
		#define M_PI 3.1415926535897932384626433832795
		out vec2 vUv;
		out vec3 vertexPos;
		uniform float iTime;
		mat4 rotationMatrix(vec3 axis, float angle)
		{
			axis = normalize(axis);
			float s = sin(angle);
			float c = cos(angle);
			float oc = 1.0 - c;

			return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
						oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
						oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
						0.0,                                0.0,                                0.0,                                1.0);
		}
		
		void main() {
			vUv = uv;
			vec4 pos = (vec4( position, 1.0 ));
			//pos =  rotationMatrix(vec3(0.0,0.0,1.0), iTime*0.5) * pos;
			gl_Position = projectionMatrix * modelViewMatrix *pos;

		}
		</script>

		<script id="fs-fireball" type="x-shader/x-fragment">
		#version 300 es
		uniform vec2 viewport;
		uniform vec2 center;
		uniform float iTime;
		uniform float scale;
		out vec4 fragColor;
		
		float snoise(vec3 uv, float res)	// by trisomie21
		{
			const vec3 s = vec3(1e0, 1e2, 1e4);

			uv *= res;

			vec3 uv0 = floor(mod(uv, res))*s;
			vec3 uv1 = floor(mod(uv+vec3(1.), res))*s;

			vec3 f = fract(uv); f = f*f*(3.0-2.0*f);

			vec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,
						  uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);

			vec4 r = fract(sin(v*1e-3)*1e5);
			float r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);

			r = fract(sin((v + uv1.z - uv0.z)*1e-3)*1e5);
			float r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);

			return mix(r0, r1, f.z)*2.-1.;
		}

		void main()
		{	
			// using gl_fragCoord will make it always face camera
			vec2 p = -.67 + gl_FragCoord.xy / viewport - center/1.8;	
			//left number controls the radius of the center
			//right numbers control general size 
			float color = 2.2 - (11.0/scale*length(p));
			//this shows how fine the particles are
			vec3 coord = vec3(atan(p.x,p.y), length(p), 0.5)/0.6;
			
			for(int i = 1; i <= 4; i++)
			{
				float power = pow(3.0, float(i));
				color += (1.5 / power) * snoise(coord + vec3(0.,-iTime*.05, iTime*.01), power*16.);
			}
			fragColor = vec4( color, pow(max(color,0.),2.)*0.4, pow(max(color,0.),2.)*0.15 , 1.0);
			if (distance(fragColor.rgb, vec3(0.0,0.0,0.0))<1.0)
				discard;
		}
		</script>
		<script id="vs-waterball" type="x-shader/x-vertex">
		#version 300 es
		#define M_PI 3.1415926535897932384626433832795
		out vec2 vUv;
		out vec3 vertexPos;
		uniform float iTime;
		mat4 rotationMatrix(vec3 axis, float angle)
		{
			axis = normalize(axis);
			float s = sin(angle);
			float c = cos(angle);
			float oc = 1.0 - c;

			return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
						oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
						oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
						0.0,                                0.0,                                0.0,                                1.0);
		}
		
		void main() {
			vUv = uv;
			vec4 pos = (vec4( position, 1.0 ));
			//pos =  rotationMatrix(vec3(0.0,0.0,1.0), iTime*0.5) * pos;
			gl_Position = projectionMatrix * modelViewMatrix *pos;

		}
		</script>

		<script id="fs-waterball" type="x-shader/x-fragment">
		#version 300 es
		uniform vec2 viewport;
		uniform sampler2D diffuse_map;
		uniform vec2 center;
		uniform float iTime;
		uniform float scale;
		out vec4 fragColor;
		

		void main()
		{	
			
		}
		</script>
		<script src="./src/Stats.js"></script>
		<script src="./src/fireball.js"></script>
		<script src="./loaders/OBJLoader.js"></script>
		<script src="./loaders/MTLLoader.js"></script>
		<script src="./loaders/GLTFLoader.js"></script>
    	<script src="./controls/OrbitControls.js"></script>
		<script src="./postprocessing/EffectComposer.js"></script>
		<script src="./postprocessing/ShaderPass.js"></script>
		<script src="./postprocessing/RenderPass.js"></script>
		<script src="./postprocessing/BloomPass.js"></script>
		<script src="./postprocessing/UnrealBloomPass.js"></script>
		<script src="./postprocessing/FilmPass.js"></script>
		<script src="./shaders/CopyShader.js"></script>
		<script src="./shaders/ConvolutionShader.js"></script>
		<script src="./shaders/FocusShader.js"></script>
		<script src="./shaders/FilmShader.js"></script>
		<script src="./shaders/LuminosityHighPassShader.js"></script>
		<script src="./src/main.js"></script>
</body>

</html>