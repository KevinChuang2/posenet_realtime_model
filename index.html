<!DOCTYPE html>

<head>
  <meta charset="UTF-8">
  <title>Posenet Real Time Model</title>


    <script src="./src/three.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow/1.2.2/tf.js"></script>
    <script src="https://unpkg.com/@tensorflow-models/posenet"></script>
    
    
    <link rel="stylesheet" href="https://use.typekit.net/tet7hit.css">

<style>
/* Style of axis */
body {
  background-color: #FFFFFF;
}

.flex {
    display: flex;
    justify-content: center;
    align-items: center;
}

h3 {
  color: #EFF6EE;
  font-family: interstate, sans-serif;
  font-weight: 250;
  font-style: normal;
}
canvas {
    position: absolute;
    top: 0;
    left: 0;
}
</style>
</head>

<body>

<div class='flex'>
  <h3>
    Posenet & three.js
  </h3>
</div>

<div class='flex'>
  <div id='main' style='display:none'>
      <video id="video" autoPlay = "true" playsinline style=" -moz-transform: scaleX(-1);
      -o-transform: scaleX(-1);
      -webkit-transform: scaleX(-1);
      transform: scaleX(-1);
      display: none;
      ">
      </video>
      <canvas id="output" />
  </div>  
</div>

<div id='threeContainer' class='flex'>
</div>
		<script id="vs-fireball" type="x-shader/x-vertex">
		#version 300 es
		#define M_PI 3.1415926535897932384626433832795
		out vec2 vUv;
		out vec3 vertexPos;
		uniform float iTime;
		mat4 rotationMatrix(vec3 axis, float angle)
		{
			axis = normalize(axis);
			float s = sin(angle);
			float c = cos(angle);
			float oc = 1.0 - c;

			return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
						oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
						oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
						0.0,                                0.0,                                0.0,                                1.0);
		}
		
		void main() {
			vUv = uv;
			vec4 pos = (vec4( position, 1.0 ));
			//pos =  rotationMatrix(vec3(0.0,0.0,1.0), iTime*0.5) * pos;
			gl_Position = projectionMatrix * modelViewMatrix *pos;

		}
		</script>

		<script id="fs-fireball" type="x-shader/x-fragment">
		#version 300 es
		uniform vec2 viewport;
		uniform vec2 center;
		uniform float iTime;
		uniform float scale;
		out vec4 fragColor;
		
		float snoise(vec3 uv, float res)	// by trisomie21
		{
			const vec3 s = vec3(1e0, 1e2, 1e4);

			uv *= res;

			vec3 uv0 = floor(mod(uv, res))*s;
			vec3 uv1 = floor(mod(uv+vec3(1.), res))*s;

			vec3 f = fract(uv); f = f*f*(3.0-2.0*f);

			vec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,
						  uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);

			vec4 r = fract(sin(v*1e-3)*1e5);
			float r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);

			r = fract(sin((v + uv1.z - uv0.z)*1e-3)*1e5);
			float r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);

			return mix(r0, r1, f.z)*2.-1.;
		}

		void main()
		{	
			// using gl_fragCoord will make it always face camera
			vec2 p = -.67 + gl_FragCoord.xy / viewport - center/1.8;	
			//left number controls the radius of the center
			//right numbers control general size 
			float color = 2.2 - (11.0/scale*length(p));
			//this shows how fine the particles are
			vec3 coord = vec3(atan(p.x,p.y), length(p), 0.5)/0.6;
			
			for(int i = 1; i <= 4; i++)
			{
				float power = pow(3.0, float(i));
				color += (1.5 / power) * snoise(coord + vec3(0.,-iTime*.05, iTime*.01), power*16.);
			}
			fragColor = vec4( color, pow(max(color,0.),2.)*0.4, pow(max(color,0.),2.)*0.15 , 1.0);
			if (distance(fragColor.rgb, vec3(0.0,0.0,0.0))<1.0)
				discard;
		}
		</script>
		<script id="vs-earthball" type="x-shader/x-vertex">
		#version 300 es
		#define M_PI 3.1415926535897932384626433832795
		out vec2 vUv;
		out vec3 vertexPos;
		uniform sampler2D bump_map;
		uniform float iTime;
		uniform vec3 center;
		float rand(vec2 n) { 
			return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);
		}
		float noise(vec2 n) {
			const vec2 d = vec2(0.0, 1.0);
			vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));
			return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);
		}
		mat4 rotationMatrix(vec3 axis, float angle)
		{
			axis = normalize(axis);
			float s = sin(angle);
			float c = cos(angle);
			float oc = 1.0 - c;

			return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
						oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
						oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
						0.0,                                0.0,                                0.0,                                1.0);
		}
		
		void main() {
			vUv = uv;
			vec4 pos = (vec4( position, 1.0 ));
			float bump = texture(bump_map, uv).r;
			pos = pos+ vec4(normal*noise(pos.xy)*2.5,0.0);
			pos =  rotationMatrix(vec3(0.0,0.0,1.0), iTime*0.5) * pos;
			vertexPos = vec3(projectionMatrix * modelViewMatrix *pos);
			gl_Position = projectionMatrix * modelViewMatrix *pos;

		}
		</script>

		<script id="fs-earthball" type="x-shader/x-fragment">
		#version 300 es
		in vec2 vUv;
		in vec3 vertexPos;
		uniform vec2 viewport;
		uniform vec3 center;
		uniform sampler2D diffuse_map;
		uniform sampler2D normal_map;
		uniform sampler2D ambientocclusion_map;
		uniform vec3 light_position;
		uniform vec3 light_color;
		uniform float iTime;
		uniform float scale;
		out vec4 fragColor;
	
		void main()
		{	
			
			vec3 Normal = texture(normal_map, vUv).rgb;
			vec3 lightDir = normalize(light_position - vertexPos);
			float ambient_occlusion = texture(ambientocclusion_map, vUv).r;
			vec3 Diffuse = texture(diffuse_map, vUv).rgb;
			vec3 diffuse = max(dot(Normal, lightDir), 0.0) * Diffuse * light_color*ambient_occlusion;
			vec3 lighting = diffuse;
			fragColor = 	vec4(lighting,1.0);
			//fragColor = 	vec4(Diffuse,1.0);

		}
		</script>
		<script id="vs-water" type="x-shader/x-vertex">
		#version 300 es
		uniform float time;
		uniform float rotationSpeed;
		out vec3 vPos;
		out vec3 vNormal;
		out vec2 vUv;
		out vec3 fragPos;
		attribute vec3 initial_position;
		float rand(vec2 co){
			return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
		}
		vec3 curve(float time) {
		  vec3 position;
		  position.x = sin(2.*time);
		  position.y = cos(2.*time);
		  position.z = 1.5*cos(3.*time);
		  return position;
		}
		mat4 rotationMatrix(vec3 axis, float angle)
		{
			axis = normalize(axis);
			float s = sin(angle);
			float c = cos(angle);
			float oc = 1.0 - c;

			return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
						oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
						oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
						0.0,                                0.0,                                0.0,                                1.0);
		}
		void main()
		{
			vUv = uv+0.05*vec2(mod(time , 0.15),mod(time, 0.15));
			vec4 pos = rotationMatrix(vec3(0.0,1.0,0.0), time*1.3) * vec4(position, 1.0);
			pos = rotationMatrix(vec3(1.0,0.0,0.0), time*1.3) * pos;
			
			vPos = vec3(pos);
			vNormal = mat3(transpose(inverse(modelMatrix))) * normal;  
			fragPos = vec3(modelMatrix * pos);
			vec4 mvPosition = modelViewMatrix * pos;

			gl_Position = projectionMatrix * mvPosition;
			
		}
		
		</script>
		<script id="fs-water" type="x-shader/x-fragment">
		#version 300 es

		precision highp float;
		precision highp int;	
		uniform sampler2D textureNoise;
		uniform sampler2D textureWater;
		uniform sampler2D waterNormal;
		uniform int side;
		uniform vec3 viewPos;
		uniform vec4 shallowColor;
		uniform vec4 deepColor;
		uniform vec3 lightPos;  
		uniform vec4 lightColor;
		in vec2 vUv;
		in vec3 vPos;
		in vec3 vNormal;
		in vec3 fragPos;
		out vec4 fragColor;
		void main()
		{
			
			float ambientStrength = 0.6;
			float specularStrength = 0.5;
			vec3 ambient = ambientStrength * lightColor.xyz;
			
			vec3 norm = texture(waterNormal,vUv).rgb;
			norm = normalize(norm * 2.0 - 1.0);   
			vec3 lightDir = normalize(lightPos - fragPos); 
			vec3 viewDir = normalize(viewPos-fragPos);
			vec3 reflectDir = reflect(-lightDir, norm);
			float diff = max(dot(norm, lightDir), 0.0);
			vec3 diffuse = diff * lightColor.xyz;

			vec4 noise = texture(textureWater, vUv);
			
			vec4 color = mix(shallowColor, deepColor, noise.y);
			float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);
			vec3 specular = specularStrength * spec * lightColor.xyz;  
			vec3 result = (ambient + diffuse+specular) * color.xyz;
			
			fragColor = vec4(result, 0.76);
		}

		</script>
		<script src="./src/Stats.js"></script>
		<script src="./src/CustomSinCurve.js"></script>
		<script src="./src/fireball.js"></script>
		<script src="./src/earthball.js"></script>
		<script src="./src/flowingWaterObject.js"></script>
		<script src="./loaders/OBJLoader.js"></script>
		<script src="./loaders/MTLLoader.js"></script>
		<script src="./loaders/GLTFLoader.js"></script>
    	<script src="./controls/OrbitControls.js"></script>
		<script src="./postprocessing/EffectComposer.js"></script>
		<script src="./postprocessing/ShaderPass.js"></script>
		<script src="./postprocessing/RenderPass.js"></script>
		<script src="./postprocessing/BloomPass.js"></script>
		<script src="./postprocessing/UnrealBloomPass.js"></script>
		<script src="./postprocessing/FilmPass.js"></script>
		<script src="./shaders/CopyShader.js"></script>
		<script src="./shaders/ConvolutionShader.js"></script>
		<script src="./shaders/FocusShader.js"></script>
		<script src="./shaders/FilmShader.js"></script>
		<script src="./shaders/LuminosityHighPassShader.js"></script>
		<script src="./src/main.js"></script>
</body>

</html>