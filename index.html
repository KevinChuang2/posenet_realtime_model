<!DOCTYPE html>

<head>
  <meta charset="UTF-8">
  <title>Posenet Real Time Model</title>


    <script src="./src/three.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow/1.2.2/tf.js"></script>
    <script src="https://unpkg.com/@tensorflow-models/posenet"></script>
    
    
    <link rel="stylesheet" href="https://use.typekit.net/tet7hit.css">

<style>
/* Style of axis */
body {
  background-color: #FFFFFF;
}

.flex {
    display: flex;
    justify-content: center;
    align-items: center;
}

h3 {
  color: #EFF6EE;
  font-family: interstate, sans-serif;
  font-weight: 250;
  font-style: normal;
}
canvas {
    position: absolute;
    top: 0;
    left: 0;
}
</style>
</head>

<body>

<div class='flex'>
  <h3>
    Posenet & three.js
  </h3>
</div>

<div class='flex'>
  <div id='main' style='display:none'>
      <video id="video" autoPlay = "true" playsinline style=" -moz-transform: scaleX(-1);
      -o-transform: scaleX(-1);
      -webkit-transform: scaleX(-1);
      transform: scaleX(-1);
      display: none;
      ">
      </video>
      <canvas id="output" style = "position:absolute; left:1000px; background-color:yellow;"/>
  </div>  
</div>

<div id='threeContainer' class='flex'>
</div>
		<script id="vs-lightning" type="x-shader/x-vertex">
		#version 300 es
		uniform vec2 offset;
		uniform float time;
		out vec3 vPos;
		float rand(vec2 co){
			return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
		}
		
		void main()
		{
			gl_Position = vec4(position.x, position.y, 0, 1.0) + vec4(offset, 0.0, 0.0);
			vPos = position.xyz;
		}
		
		</script>

		<script id="fs-lightning" type="x-shader/x-fragment">
		#version 300 es

		precision highp float;
		precision highp int;	
		uniform sampler2D tDiffuse;
		uniform float opacity;
		uniform vec3 colorVal;
		out vec4 fragColor;
		uniform float time;
		uniform vec3 begin;
		uniform vec3 end;
		float period = 0.3;
		float fTime;
		vec3 fPos;
		float spikeFunc;
		float spikeTime= 0.2;
		in vec3 vPos;
		void main()
		{
			fTime = time;
			fPos = gl_FragCoord.xyz;
			while(fTime>period)
			{
				fTime -= period;
			}

			float fDist = distance(vPos, begin);
			float endDist = distance(end,begin);
			float distRatio = fDist/endDist*period;
			if((period-distRatio)-(spikeTime/2.0) < fTime && fTime<(period-distRatio)+(spikeTime/2.0))
			{
				if((period-distRatio) > fTime)
				{
					spikeFunc = 1.0-(period-distRatio-fTime);
				}
				else
				{
					spikeFunc = 1.0 + (period-distRatio-fTime);
				}
			}
			else
			{
				spikeFunc = 0.0;
			}
			
			fragColor = vec4(colorVal, spikeFunc*opacity);

		}

		</script>
		<script id="vs-water" type="x-shader/x-vertex">
		#version 300 es
		uniform float time;
		uniform float rotationSpeed;
		out vec3 vPos;
		out vec3 vNormal;
		out vec2 vUv;
		out vec3 fragPos;
		attribute vec3 initial_position;
		float rand(vec2 co){
			return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
		}
		vec3 curve(float time) {
		  vec3 position;
		  position.x = sin(2.*time);
		  position.y = cos(2.*time);
		  position.z = 1.5*cos(3.*time);
		  return position;
		}
		mat4 rotationMatrix(vec3 axis, float angle)
		{
			axis = normalize(axis);
			float s = sin(angle);
			float c = cos(angle);
			float oc = 1.0 - c;

			return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
						oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
						oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
						0.0,                                0.0,                                0.0,                                1.0);
		}
		void main()
		{
			vUv = uv+0.05*vec2(mod(time , 0.15),mod(time, 0.15));
			vec4 pos = rotationMatrix(vec3(0.0,1.0,0.0), time*1.3) * vec4(position, 1.0);
			pos = rotationMatrix(vec3(1.0,0.0,0.0), time*1.3) * pos;
			
			vPos = vec3(pos);
			vNormal = mat3(transpose(inverse(modelMatrix))) * normal;  
			fragPos = vec3(modelMatrix * pos);
			vec4 mvPosition = modelViewMatrix * pos;

			gl_Position = projectionMatrix * mvPosition;
			
		}
		
		</script>
		<script id="fs-water" type="x-shader/x-fragment">
		#version 300 es

		precision highp float;
		precision highp int;	
		uniform sampler2D textureNoise;
		uniform sampler2D textureWater;
		uniform sampler2D waterNormal;
		uniform int side;
		uniform vec3 viewPos;
		uniform vec4 shallowColor;
		uniform vec4 deepColor;
		uniform vec3 lightPos;  
		uniform vec4 lightColor;
		in vec2 vUv;
		in vec3 vPos;
		in vec3 vNormal;
		in vec3 fragPos;
		out vec4 fragColor;
		void main()
		{
			
			float ambientStrength = 0.6;
			float specularStrength = 0.5;
			vec3 ambient = ambientStrength * lightColor.xyz;
			
			vec3 norm = texture(waterNormal,vUv).rgb;
			norm = normalize(norm * 2.0 - 1.0);   
			vec3 lightDir = normalize(lightPos - fragPos); 
			vec3 viewDir = normalize(viewPos-fragPos);
			vec3 reflectDir = reflect(-lightDir, norm);
			float diff = max(dot(norm, lightDir), 0.0);
			vec3 diffuse = diff * lightColor.xyz;

			vec4 noise = texture(textureWater, vUv);
			
			vec4 color = mix(shallowColor, deepColor, noise.y);
			float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);
			vec3 specular = specularStrength * spec * lightColor.xyz;  
			vec3 result = (ambient + diffuse+specular) * color.xyz;
			
			fragColor = vec4(result, 0.76);
		}

		</script>
		<script id="vs-lavaball" type="x-shader/x-vertex">
		#version 300 es
		#define M_PI 3.1415926535897932384626433832795
		uniform float time;
		uniform vec2 uvScale;
		out vec2 vUv;
		out vec3 vertexPos;
		//
		// GLSL textureless classic 3D noise "cnoise",
		// with an RSL-style periodic variant "pnoise".
		// Author:  Stefan Gustavson (stefan.gustavson@liu.se)
		// Version: 2011-10-11
		//
		// Many thanks to Ian McEwan of Ashima Arts for the
		// ideas for permutation and gradient selection.
		//
		// Copyright (c) 2011 Stefan Gustavson. All rights reserved.
		// Distributed under the MIT license. See LICENSE file.
		// https://github.com/ashima/webgl-noise
		//

		vec3 mod289(vec3 x)
		{
		  return x - floor(x * (1.0 / 289.0)) * 289.0;
		}

		vec4 mod289(vec4 x)
		{
		  return x - floor(x * (1.0 / 289.0)) * 289.0;
		}

		vec4 permute(vec4 x)
		{
		  return mod289(((x*34.0)+1.0)*x);
		}

		vec4 taylorInvSqrt(vec4 r)
		{
		  return 1.79284291400159 - 0.85373472095314 * r;
		}

		vec3 fade(vec3 t) {
		  return t*t*t*(t*(t*6.0-15.0)+10.0);
		}

		// Classic Perlin noise
		float cnoise(vec3 P)
		{
		  vec3 Pi0 = floor(P); // Integer part for indexing
		  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1
		  Pi0 = mod289(Pi0);
		  Pi1 = mod289(Pi1);
		  vec3 Pf0 = fract(P); // Fractional part for interpolation
		  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
		  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
		  vec4 iy = vec4(Pi0.yy, Pi1.yy);
		  vec4 iz0 = Pi0.zzzz;
		  vec4 iz1 = Pi1.zzzz;

		  vec4 ixy = permute(permute(ix) + iy);
		  vec4 ixy0 = permute(ixy + iz0);
		  vec4 ixy1 = permute(ixy + iz1);

		  vec4 gx0 = ixy0 * (1.0 / 7.0);
		  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
		  gx0 = fract(gx0);
		  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
		  vec4 sz0 = step(gz0, vec4(0.0));
		  gx0 -= sz0 * (step(0.0, gx0) - 0.5);
		  gy0 -= sz0 * (step(0.0, gy0) - 0.5);

		  vec4 gx1 = ixy1 * (1.0 / 7.0);
		  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
		  gx1 = fract(gx1);
		  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
		  vec4 sz1 = step(gz1, vec4(0.0));
		  gx1 -= sz1 * (step(0.0, gx1) - 0.5);
		  gy1 -= sz1 * (step(0.0, gy1) - 0.5);

		  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
		  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
		  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
		  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
		  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
		  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
		  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
		  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

		  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
		  g000 *= norm0.x;
		  g010 *= norm0.y;
		  g100 *= norm0.z;
		  g110 *= norm0.w;
		  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
		  g001 *= norm1.x;
		  g011 *= norm1.y;
		  g101 *= norm1.z;
		  g111 *= norm1.w;

		  float n000 = dot(g000, Pf0);
		  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
		  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
		  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
		  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
		  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
		  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
		  float n111 = dot(g111, Pf1);

		  vec3 fade_xyz = fade(Pf0);
		  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
		  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
		  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
		  return 2.2 * n_xyz;
		}

		// Classic Perlin noise, periodic variant
		float pnoise(vec3 P, vec3 rep)
		{
		  vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period
		  vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period
		  Pi0 = mod289(Pi0);
		  Pi1 = mod289(Pi1);
		  vec3 Pf0 = fract(P); // Fractional part for interpolation
		  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
		  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
		  vec4 iy = vec4(Pi0.yy, Pi1.yy);
		  vec4 iz0 = Pi0.zzzz;
		  vec4 iz1 = Pi1.zzzz;

		  vec4 ixy = permute(permute(ix) + iy);
		  vec4 ixy0 = permute(ixy + iz0);
		  vec4 ixy1 = permute(ixy + iz1);

		  vec4 gx0 = ixy0 * (1.0 / 7.0);
		  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
		  gx0 = fract(gx0);
		  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
		  vec4 sz0 = step(gz0, vec4(0.0));
		  gx0 -= sz0 * (step(0.0, gx0) - 0.5);
		  gy0 -= sz0 * (step(0.0, gy0) - 0.5);

		  vec4 gx1 = ixy1 * (1.0 / 7.0);
		  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
		  gx1 = fract(gx1);
		  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
		  vec4 sz1 = step(gz1, vec4(0.0));
		  gx1 -= sz1 * (step(0.0, gx1) - 0.5);
		  gy1 -= sz1 * (step(0.0, gy1) - 0.5);

		  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
		  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
		  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
		  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
		  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
		  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
		  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
		  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

		  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
		  g000 *= norm0.x;
		  g010 *= norm0.y;
		  g100 *= norm0.z;
		  g110 *= norm0.w;
		  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
		  g001 *= norm1.x;
		  g011 *= norm1.y;
		  g101 *= norm1.z;
		  g111 *= norm1.w;

		  float n000 = dot(g000, Pf0);
		  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
		  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
		  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
		  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
		  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
		  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
		  float n111 = dot(g111, Pf1);

		  vec3 fade_xyz = fade(Pf0);
		  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
		  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
		  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
		  return 2.2 * n_xyz;
		}
		float turbulence( vec3 p ) {

		  float w = 100.0;
		  float t = -.5;

		  for (float f = 1.0 ; f <= 10.0 ; f++ ){
			float power = pow( 2.0, f );
			t += abs( pnoise( vec3( power * p ), vec3( 10.0, 10.0, 10.0 ) ) / power );
		  }

		  return t;

		}
		void main() {
			float u = atan(normal.x, normal.z)/ (2.0*M_PI)+0.5;
			float v = normal.y*0.5+0.5;
			vec2 temp = vec2(u,v);
			vUv = uvScale*uv;
			vec4 pos = vec4(position,1.0);
			vertexPos = vec3(projectionMatrix * modelViewMatrix *pos);
			// get a turbulent 3d noise using the normal, normal to high freq
			float noise = 5.0 *  -.5 * turbulence( .5 * normal + vec3(time/10.));
			// get a 3d noise using the position, low frequency
			float b = 5.0 * pnoise( 0.05 * position + vec3(time/10.), vec3( 100.0 ) );
			// compose both noises
			float displacement = - 0.05 * noise + 0.004*b;

			// move the position along the normal and transform it
			vec3 newPosition = position + normal * displacement;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );
			//gl_Position = projectionMatrix * modelViewMatrix *pos;

		}
		</script>

		<script id="fs-lavaball" type="x-shader/x-fragment">
		#version 300 es
		in vec2 vUv;
		in vec3 vertexPos;
		uniform sampler2D texture1;
		uniform sampler2D texture2;
		uniform float time;
		out vec4 fragColor;
		void main()
		{	
			
			vec2 position = - 1.0 + 2.0 * vUv;

				vec4 noise = texture2D( texture1, vUv );
				vec2 T1 = vUv + vec2( 2.0,2.0 ) * time * 0.05;
				vec2 T2 = vUv + vec2( - 0.5, 2.0 ) * time * 0.02;

				T1.x += noise.x * 2.0;
				T1.y += noise.y * 2.0;
				T2.x -= noise.y * 0.2;
				T2.y += noise.z * 0.2;

				float p = texture2D( texture1, T1 * 2.0 ).a;

				vec4 color = texture2D( texture2, T2 * 2.0 );
				vec4 temp = color * ( vec4( p, p, p, p ) * 2.0 ) + ( color * color - 0.1 );


				fragColor = temp;



		}
		</script>
		<script src="./src/Stats.js"></script>
		<script src="./src/animationHandler.js"></script>
		<script src="./src/lightning.js"></script>
		<script src="./src/CustomSinCurve.js"></script>
		<script src="./src/Helix.js"></script>
		<script src="./src/fireball.js"></script>
		<script src="./src/lava.js"></script>
		<script src="./src/Fire.js"></script>
		<script src="./src/FireShader.js"></script>
		<script src="./src/flowingWaterObject.js"></script>
		<script src="./loaders/GLTFLoader.js"></script>
    	<script src="./controls/OrbitControls.js"></script>
		<script src="./postprocessing/EffectComposer.js"></script>
		<script src="./postprocessing/ShaderPass.js"></script>
		<script src="./postprocessing/RenderPass.js"></script>
		<script src="./postprocessing/BloomPass.js"></script>
		<script src="./postprocessing/UnrealBloomPass.js"></script>
		<script src="./shaders/CopyShader.js"></script>
		<script src="./shaders/ConvolutionShader.js"></script>
		<script src="./shaders/FocusShader.js"></script>
		<script src="./shaders/FilmShader.js"></script>
		<script src="./shaders/LuminosityHighPassShader.js"></script>
		<script src="./src/main.js"></script>
</body>

</html>