<html>
	<head>
		<title> Testing Scene</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	<div id="container"> </div>
	</head>
	<body>
		<script id="vs-fireball" type="x-shader/x-vertex">
		#version 300 es
		#define M_PI 3.1415926535897932384626433832795
		out vec2 vUv;
		out vec3 vertexPos;
		uniform float iTime;
		mat4 rotationMatrix(vec3 axis, float angle)
		{
			axis = normalize(axis);
			float s = sin(angle);
			float c = cos(angle);
			float oc = 1.0 - c;

			return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
						oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
						oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
						0.0,                                0.0,                                0.0,                                1.0);
		}
		
		void main() {
			vUv = uv;
			vec4 pos = (vec4( position, 1.0 ));
			//pos =  rotationMatrix(vec3(0.0,0.0,1.0), iTime*0.5) * pos;
			gl_Position = projectionMatrix * modelViewMatrix *pos;

		}
		</script>

		<script id="fs-fireball" type="x-shader/x-fragment">
		#version 300 es
		uniform vec2 viewport;
		uniform float insideRadius;
		uniform float iTime;
		out vec4 fragColor;
		
		float snoise(vec3 uv, float res)	// by trisomie21
		{
			const vec3 s = vec3(1e0, 1e2, 1e4);

			uv *= res;

			vec3 uv0 = floor(mod(uv, res))*s;
			vec3 uv1 = floor(mod(uv+vec3(1.), res))*s;

			vec3 f = fract(uv); f = f*f*(3.0-2.0*f);

			vec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,
						  uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);

			vec4 r = fract(sin(v*1e-3)*1e5);
			float r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);

			r = fract(sin((v + uv1.z - uv0.z)*1e-3)*1e5);
			float r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);

			return mix(r0, r1, f.z)*2.-1.;
		}

		void main()
		{	
			// using gl_fragCoord will make it always face camera
			vec2 p = -.67 + gl_FragCoord.xy / viewport;	
			//left number controls the radius of the center
			//right numbers control general size 
			float color = 2.5 - (25.0*length(p));
			//this shows how fine the particles are
			vec3 coord = vec3(atan(p.x,p.y), length(p), 0.5)/0.6;
			
			for(int i = 1; i <= 4; i++)
			{
				float power = pow(3.0, float(i));
				color += (1.5 / power) * snoise(coord + vec3(0.,-iTime*.05, iTime*.01), power*16.);
			}
			fragColor = vec4( color, pow(max(color,0.),2.)*0.4, pow(max(color,0.),2.)*0.15 , 1.0);
		}
		</script>
		<script id="vs-lavaball" type="x-shader/x-vertex">
		#version 300 es
		#define M_PI 3.1415926535897932384626433832795
		uniform float time;
		uniform vec2 uvScale;
		out vec2 vUv;
		out vec3 vertexPos;
		//
		// GLSL textureless classic 3D noise "cnoise",
		// with an RSL-style periodic variant "pnoise".
		// Author:  Stefan Gustavson (stefan.gustavson@liu.se)
		// Version: 2011-10-11
		//
		// Many thanks to Ian McEwan of Ashima Arts for the
		// ideas for permutation and gradient selection.
		//
		// Copyright (c) 2011 Stefan Gustavson. All rights reserved.
		// Distributed under the MIT license. See LICENSE file.
		// https://github.com/ashima/webgl-noise
		//

		vec3 mod289(vec3 x)
		{
		  return x - floor(x * (1.0 / 289.0)) * 289.0;
		}

		vec4 mod289(vec4 x)
		{
		  return x - floor(x * (1.0 / 289.0)) * 289.0;
		}

		vec4 permute(vec4 x)
		{
		  return mod289(((x*34.0)+1.0)*x);
		}

		vec4 taylorInvSqrt(vec4 r)
		{
		  return 1.79284291400159 - 0.85373472095314 * r;
		}

		vec3 fade(vec3 t) {
		  return t*t*t*(t*(t*6.0-15.0)+10.0);
		}

		// Classic Perlin noise
		float cnoise(vec3 P)
		{
		  vec3 Pi0 = floor(P); // Integer part for indexing
		  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1
		  Pi0 = mod289(Pi0);
		  Pi1 = mod289(Pi1);
		  vec3 Pf0 = fract(P); // Fractional part for interpolation
		  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
		  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
		  vec4 iy = vec4(Pi0.yy, Pi1.yy);
		  vec4 iz0 = Pi0.zzzz;
		  vec4 iz1 = Pi1.zzzz;

		  vec4 ixy = permute(permute(ix) + iy);
		  vec4 ixy0 = permute(ixy + iz0);
		  vec4 ixy1 = permute(ixy + iz1);

		  vec4 gx0 = ixy0 * (1.0 / 7.0);
		  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
		  gx0 = fract(gx0);
		  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
		  vec4 sz0 = step(gz0, vec4(0.0));
		  gx0 -= sz0 * (step(0.0, gx0) - 0.5);
		  gy0 -= sz0 * (step(0.0, gy0) - 0.5);

		  vec4 gx1 = ixy1 * (1.0 / 7.0);
		  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
		  gx1 = fract(gx1);
		  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
		  vec4 sz1 = step(gz1, vec4(0.0));
		  gx1 -= sz1 * (step(0.0, gx1) - 0.5);
		  gy1 -= sz1 * (step(0.0, gy1) - 0.5);

		  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
		  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
		  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
		  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
		  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
		  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
		  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
		  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

		  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
		  g000 *= norm0.x;
		  g010 *= norm0.y;
		  g100 *= norm0.z;
		  g110 *= norm0.w;
		  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
		  g001 *= norm1.x;
		  g011 *= norm1.y;
		  g101 *= norm1.z;
		  g111 *= norm1.w;

		  float n000 = dot(g000, Pf0);
		  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
		  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
		  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
		  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
		  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
		  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
		  float n111 = dot(g111, Pf1);

		  vec3 fade_xyz = fade(Pf0);
		  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
		  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
		  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
		  return 2.2 * n_xyz;
		}

		// Classic Perlin noise, periodic variant
		float pnoise(vec3 P, vec3 rep)
		{
		  vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period
		  vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period
		  Pi0 = mod289(Pi0);
		  Pi1 = mod289(Pi1);
		  vec3 Pf0 = fract(P); // Fractional part for interpolation
		  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
		  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
		  vec4 iy = vec4(Pi0.yy, Pi1.yy);
		  vec4 iz0 = Pi0.zzzz;
		  vec4 iz1 = Pi1.zzzz;

		  vec4 ixy = permute(permute(ix) + iy);
		  vec4 ixy0 = permute(ixy + iz0);
		  vec4 ixy1 = permute(ixy + iz1);

		  vec4 gx0 = ixy0 * (1.0 / 7.0);
		  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;
		  gx0 = fract(gx0);
		  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
		  vec4 sz0 = step(gz0, vec4(0.0));
		  gx0 -= sz0 * (step(0.0, gx0) - 0.5);
		  gy0 -= sz0 * (step(0.0, gy0) - 0.5);

		  vec4 gx1 = ixy1 * (1.0 / 7.0);
		  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;
		  gx1 = fract(gx1);
		  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
		  vec4 sz1 = step(gz1, vec4(0.0));
		  gx1 -= sz1 * (step(0.0, gx1) - 0.5);
		  gy1 -= sz1 * (step(0.0, gy1) - 0.5);

		  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
		  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
		  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
		  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
		  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
		  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
		  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
		  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

		  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
		  g000 *= norm0.x;
		  g010 *= norm0.y;
		  g100 *= norm0.z;
		  g110 *= norm0.w;
		  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
		  g001 *= norm1.x;
		  g011 *= norm1.y;
		  g101 *= norm1.z;
		  g111 *= norm1.w;

		  float n000 = dot(g000, Pf0);
		  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
		  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
		  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
		  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
		  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
		  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
		  float n111 = dot(g111, Pf1);

		  vec3 fade_xyz = fade(Pf0);
		  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
		  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
		  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
		  return 2.2 * n_xyz;
		}
		float turbulence( vec3 p ) {

		  float w = 100.0;
		  float t = -.5;

		  for (float f = 1.0 ; f <= 10.0 ; f++ ){
			float power = pow( 2.0, f );
			t += abs( pnoise( vec3( power * p ), vec3( 10.0, 10.0, 10.0 ) ) / power );
		  }

		  return t;

		}
		void main() {
			float u = atan(normal.x, normal.z)/ (2.0*M_PI)+0.5;
			float v = normal.y*0.5+0.5;
			vec2 temp = vec2(u,v);
			vUv = uvScale*uv;
			vec4 pos = vec4(position,1.0);
			vertexPos = vec3(projectionMatrix * modelViewMatrix *pos);
			// get a turbulent 3d noise using the normal, normal to high freq
			float noise = 5.0 *  -.5 * turbulence( .5 * normal + vec3(time/10.));
			// get a 3d noise using the position, low frequency
			float b = 5.0 * pnoise( 0.05 * position + vec3(time/10.), vec3( 100.0 ) );
			// compose both noises
			float displacement = - 0.05 * noise + 0.004*b;

			// move the position along the normal and transform it
			vec3 newPosition = position + normal * displacement;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );
			//gl_Position = projectionMatrix * modelViewMatrix *pos;

		}
		</script>

		<script id="fs-lavaball" type="x-shader/x-fragment">
		#version 300 es
		in vec2 vUv;
		in vec3 vertexPos;
		uniform sampler2D texture1;
		uniform sampler2D texture2;
		uniform float time;
		out vec4 fragColor;
		void main()
		{	
			
			vec2 position = - 1.0 + 2.0 * vUv;

				vec4 noise = texture2D( texture1, vUv );
				vec2 T1 = vUv + vec2( 2.0,2.0 ) * time * 0.05;
				vec2 T2 = vUv + vec2( - 0.5, 2.0 ) * time * 0.02;

				T1.x += noise.x * 2.0;
				T1.y += noise.y * 2.0;
				T2.x -= noise.y * 0.2;
				T2.y += noise.z * 0.2;

				float p = texture2D( texture1, T1 * 2.0 ).a;

				vec4 color = texture2D( texture2, T2 * 2.0 );
				vec4 temp = color * ( vec4( p, p, p, p ) * 2.0 ) + ( color * color - 0.1 );


				fragColor = temp;



		}
		</script>
		<script id="vs-water" type="x-shader/x-vertex">
		#version 300 es
		uniform float time;
		uniform float rotationSpeed;
		uniform float wrapNum;
		uniform sampler2D waterBump;
		uniform sampler2D waterNormal;
		attribute vec3 tangent;
		attribute vec3 bitangent;
		out vec3 vPos;
		out vec2 vUv;
		out vec2 vUv2;
		out vec3 fragPos;
		out vec3 vNormal;
		out vec3 vTangent;
		out vec3 vBitangent;
		out mat3 TBN;
		float rand(vec2 co){
			return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
		}
		mat2 rotate2d(float _angle){
			return mat2(cos(_angle),-sin(_angle),
						sin(_angle),cos(_angle));
		}
		mat4 rotationMatrix(vec3 axis, float angle)
		{
			axis = normalize(axis);
			float s = sin(angle);
			float c = cos(angle);
			float oc = 1.0 - c;

			return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
						oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
						oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
						0.0,                                0.0,                                0.0,                                1.0);
		}
		void main()
		{
			
			vUv2 = vec2(wrapNum*uv.x, uv.y);
			vUv = normalize(normal).xy*0.5+0.5;
			vec4 pos = vec4(position,1.0);
			vPos = vec3(pos);
			fragPos = vec3(modelMatrix * pos);
			vec4 mvPosition = modelViewMatrix * pos;
			vNormal = normal;
			vec3 surfaceNorm = normalize((modelViewMatrix*vec4(normal,0.0)).xyz);
			vec3 T = normalize(vec3(modelMatrix * vec4(tangent, 0.0)));
			vec3 N = normalize(vec3(modelMatrix * vec4(normal, 0.0)));
			// re-orthogonalize T with respect to N
			T = normalize(T - dot(T, N) * N);
			// then retrieve perpendicular vector B with the cross product of T and N
			vec3 B = cross(N, T);
		    vTangent = tangent;
		    vBitangent = B;
			TBN = mat3(T, B, N); 
			gl_Position = projectionMatrix * mvPosition;
			
		}
		
		</script>
		<script id="fs-water" type="x-shader/x-fragment">
		#version 300 es

		precision highp float;
		precision highp int;	
		uniform sampler2D textureNoise;
		uniform sampler2D textureWater;
		uniform sampler2D waterNormal;
		uniform sampler2D waterOcclusion;
		uniform sampler2D waterRoughness;
		uniform vec3 lightColor;
		uniform vec3 lightPos;
		uniform vec3 viewPos;
		in vec2 vUv;
		in vec2 vUv2;
		in vec3 vPos;
		in vec3 fragPos;
		in vec3 vTangent;
		in vec3 vBitangent;
		in vec3 vNormal;
		in mat3 TBN;
		out vec4 fragColor;
		const float PI = 3.14159265359;
		float DistributionGGX(vec3 N, vec3 H, float roughness)
		{
			float a = roughness*roughness;
			float a2 = a*a;
			float NdotH = max(dot(N, H), 0.0);
			float NdotH2 = NdotH*NdotH;

			float nom   = a2;
			float denom = (NdotH2 * (a2 - 1.0) + 1.0);
			denom = PI * denom * denom;

			return nom / max(denom, 0.001); // prevent divide by zero for roughness=0.0 and NdotH=1.0
		}
		// ----------------------------------------------------------------------------
		float GeometrySchlickGGX(float NdotV, float roughness)
		{
			float r = (roughness + 1.0);
			float k = (r*r) / 8.0;

			float nom   = NdotV;
			float denom = NdotV * (1.0 - k) + k;

			return nom / denom;
		}
		// ----------------------------------------------------------------------------
		float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)
		{
			float NdotV = max(dot(N, V), 0.0);
			float NdotL = max(dot(N, L), 0.0);
			float ggx2 = GeometrySchlickGGX(NdotV, roughness);
			float ggx1 = GeometrySchlickGGX(NdotL, roughness);

			return ggx1 * ggx2;
		}
		vec3 fresnelSchlick(float cosTheta, vec3 F0)
		{
			return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
		}
		void main()
		{

			vec3 albedo     =texture(textureWater, vUv).rgb;
			vec3 normal     = texture(waterNormal, vUv).rgb*2.0-1.0;
			float metallic  = 0.0;
			float roughness = texture(waterRoughness, vUv).r;
			float ao        = texture(waterOcclusion, vUv).r;
			vec3 N = TBN* normalize(normal);
			vec3 V = TBN* normalize(viewPos - fragPos);
			vec3 L = TBN * normalize(lightPos - fragPos);
			vec3 H = normalize(V + L);
			// calculate reflectance at normal incidence; if dia-electric (like plastic) use F0 
			// of 0.04 and if it's a metal, use the albedo color as F0 (metallic workflow)    
			vec3 F0 = vec3(0.04); 
			F0 = mix(F0, albedo, metallic);

			// reflectance equation
			vec3 Lo = vec3(0.0);
			// calculate per-light radiance
			float distance = length(lightPos - fragPos);
			float attenuation = 1.0 / (distance * distance);
			vec3 radiance = lightColor * attenuation;

			// Cook-Torrance BRDF
			float NDF = DistributionGGX(N, H, roughness);   
			float G   = GeometrySmith(N, V, L, roughness);      
			vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0);

			vec3 nominator    = NDF * G * F; 
			float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001; // 0.001 to prevent divide by zero.
			vec3 specular = nominator / denominator;

			// kS is equal to Fresnel
			vec3 kS = F;
			// for energy conservation, the diffuse and specular light can't
			// be above 1.0 (unless the surface emits light); to preserve this
			// relationship the diffuse component (kD) should equal 1.0 - kS.
			vec3 kD = vec3(1.0) - kS;
			// multiply kD by the inverse metalness such that only non-metals 
			// have diffuse lighting, or a linear blend if partly metal (pure metals
			// have no diffuse light).
			kD *= 1.0 - metallic;	  

			// scale light by NdotL
			float NdotL = max(dot(N, L), 0.0);        

			// add to outgoing radiance Lo
			Lo += (kD * albedo / PI + specular) * radiance * NdotL;  // note that we already multiplied the BRDF by the Fresnel (kS) so we won't multiply by kS again
			

			// ambient lighting (note that the next IBL tutorial will replace 
			// this ambient lighting with environment lighting).
			vec3 ambient = vec3(0.05) * albedo * ao;

			vec3 color = ambient + Lo;

			// HDR tonemapping
			color = color / (color + vec3(1.0));
			// gamma correct
			color = pow(color, vec3(1.0/2.2)); 

			fragColor = vec4(color, 1.0);
			
		}

		</script>
		<script src="./src/three.js"></script>
		<script src="./src/TextureAnimator.js"></script>
		<script src="./src/FireShader.js"></script>
		<script src="./src/Fire.js"></script>
		
		<script src="./controls/OrbitControls.js"></script>
		<script src="./postprocessing/EffectComposer.js"></script>
		<script src="./utils/BufferGeometryUtils.js"></script>
		<script src="./postprocessing/ShaderPass.js"></script>
		<script src="./postprocessing/RenderPass.js"></script>
		<script src="./postprocessing/BloomPass.js"></script>
		<script src="./postprocessing/UnrealBloomPass.js"></script>
		<script src="./postprocessing/FilmPass.js"></script>
		<script src="./shaders/CopyShader.js"></script>
		<script src="./shaders/ConvolutionShader.js"></script>
		<script src="./shaders/FocusShader.js"></script>
		<script src="./shaders/FilmShader.js"></script>
		<script src="./shaders/LuminosityHighPassShader.js"></script>
		<script src="./src/fireball.js"></script>
		<script src="./src/lava.js"></script>
		<script src="./src/Helix.js"></script>
		<script src="./src/CustomSinCurve.js"></script>
		<script src="./src/flowingWaterObject.js"></script>	
		<script src="./src/test.js" type = "module"></script>
	</body>
</html>